// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "github.com/mitchellh/mapstructure"
import "strings"

import "encoding/json"
import "fmt"
import "github.com/atombender/go-jsonschema/pkg/types"
import "reflect"
import "regexp"

type Analysis struct {
	// List of all author aliases associated with this analysis.  The corresponding
	// author information is found in the authors mapping.
	Auth []string `json:"auth,omitempty" yaml:"auth,omitempty" mapstructure:"auth,omitempty"`

	// Text describing the analysis, corresponding to the VEX 'detail'.
	Desc string `json:"desc" yaml:"desc" mapstructure:"desc"`

	// Just corresponds to the JSON schema field "just".
	Just *Sbom16Justification `json:"just,omitempty" yaml:"just,omitempty" mapstructure:"just,omitempty"`

	// On corresponds to the JSON schema field "on".
	On types.SerializableDate `json:"on" yaml:"on" mapstructure:"on"`

	// Resp corresponds to the JSON schema field "resp".
	Resp Sbom16Response `json:"resp,omitempty" yaml:"resp,omitempty" mapstructure:"resp,omitempty"`

	// State corresponds to the JSON schema field "state".
	State Sbom16State `json:"state" yaml:"state" mapstructure:"state"`
}

// An analysis of one or more vulnerability, in terms of how it affects the
// product.
type AnalysisGroup struct {
	// List of analysis for the issue.
	An []Analysis `json:"an" yaml:"an" mapstructure:"an"`

	// List of the direct dependency pURL affected by this vulnerability.
	Deps []PUrl `json:"deps,omitempty" yaml:"deps,omitempty" mapstructure:"deps,omitempty"`

	// List of product source code under analysis.
	Src []SourceFile `json:"src,omitempty" yaml:"src,omitempty" mapstructure:"src,omitempty"`

	// List of the transitive dependency pURL affected by this vulnerability.
	TransDeps [][]PUrl `json:"trans-deps,omitempty" yaml:"trans-deps,omitempty" mapstructure:"trans-deps,omitempty"`

	// Affected released product versions.
	Ver []AnalysisGroupVerElem `json:"ver" yaml:"ver" mapstructure:"ver"`

	// List of all the vulnerability identifiers (e.g. CVE) that this analysis covers.
	// Note that a vulnerability might exist in several analysis, as it may cover
	// multiple dependencies or parts of the code.
	Vid []string `json:"vid" yaml:"vid" mapstructure:"vid"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

type AnalysisGroupVerElem struct {
	// Architecture corresponds to the JSON schema field "architecture".
	Architecture []string `json:"architecture,omitempty" yaml:"architecture,omitempty" mapstructure:"architecture,omitempty"`

	// Before corresponds to the JSON schema field "before".
	Before *string `json:"before,omitempty" yaml:"before,omitempty" mapstructure:"before,omitempty"`

	// First corresponds to the JSON schema field "first".
	First *string `json:"first,omitempty" yaml:"first,omitempty" mapstructure:"first,omitempty"`

	// Last corresponds to the JSON schema field "last".
	Last *string `json:"last,omitempty" yaml:"last,omitempty" mapstructure:"last,omitempty"`

	// Version corresponds to the JSON schema field "version".
	Version *string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalysisGroupVerElem) UnmarshalJSON(b []byte) error {
	type Plain AnalysisGroupVerElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Before != nil && len(*plain.Before) > 100 {
		return fmt.Errorf("field %s length: must be <= %d", "before", 100)
	}
	if plain.First != nil && len(*plain.First) > 100 {
		return fmt.Errorf("field %s length: must be <= %d", "first", 100)
	}
	if plain.Last != nil && len(*plain.Last) > 100 {
		return fmt.Errorf("field %s length: must be <= %d", "last", 100)
	}
	if plain.Version != nil && len(*plain.Version) > 100 {
		return fmt.Errorf("field %s length: must be <= %d", "version", 100)
	}
	*j = AnalysisGroupVerElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AnalysisGroup) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["an"]; raw != nil && !ok {
		return fmt.Errorf("field an in AnalysisGroup: required")
	}
	if _, ok := raw["ver"]; raw != nil && !ok {
		return fmt.Errorf("field ver in AnalysisGroup: required")
	}
	if _, ok := raw["vid"]; raw != nil && !ok {
		return fmt.Errorf("field vid in AnalysisGroup: required")
	}
	type Plain AnalysisGroup
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.An) > 100 {
		return fmt.Errorf("field %s length: must be <= %d", "an", 100)
	}
	if len(plain.Deps) > 100 {
		return fmt.Errorf("field %s length: must be <= %d", "deps", 100)
	}
	if len(plain.Src) > 100 {
		return fmt.Errorf("field %s length: must be <= %d", "src", 100)
	}
	if len(plain.TransDeps) > 100 {
		return fmt.Errorf("field %s length: must be <= %d", "trans-deps", 100)
	}
	for i1 := range plain.TransDeps {
		if len(plain.TransDeps[i1]) > 100 {
			return fmt.Errorf("field %s length: must be <= %d", fmt.Sprintf("trans-deps[%d]", i1), 100)
		}
	}
	if len(plain.Ver) > 100 {
		return fmt.Errorf("field %s length: must be <= %d", "ver", 100)
	}
	if len(plain.Vid) > 100 {
		return fmt.Errorf("field %s length: must be <= %d", "vid", 100)
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = AnalysisGroup(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Analysis) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["desc"]; raw != nil && !ok {
		return fmt.Errorf("field desc in Analysis: required")
	}
	if _, ok := raw["on"]; raw != nil && !ok {
		return fmt.Errorf("field on in Analysis: required")
	}
	if _, ok := raw["state"]; raw != nil && !ok {
		return fmt.Errorf("field state in Analysis: required")
	}
	type Plain Analysis
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Auth) > 100 {
		return fmt.Errorf("field %s length: must be <= %d", "auth", 100)
	}
	if len(plain.Desc) > 10000 {
		return fmt.Errorf("field %s length: must be <= %d", "desc", 10000)
	}
	*j = Analysis(plain)
	return nil
}

// Detailed information about an author referenced in this document.
type AuthorDetail struct {
	// List of methods to contact the author.
	Contact []ContactInformation `json:"contact,omitempty" yaml:"contact,omitempty" mapstructure:"contact,omitempty"`

	// Name of the author.  If it matches the 'organization', then, for attribution
	// purposes, the organization counts as the author of this analysis.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Organization associated with the author.  As the details do not require this,
	// it should be assumed to match the product's organization if not given.  By
	// convention, individuals from outside the project unassociated with a specific
	// organization should use 'individual'.
	Organization *string `json:"organization,omitempty" yaml:"organization,omitempty" mapstructure:"organization,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthorDetail) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in AuthorDetail: required")
	}
	type Plain AuthorDetail
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Contact) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "contact", 30)
	}
	if len(plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	if len(plain.Name) > 500 {
		return fmt.Errorf("field %s length: must be <= %d", "name", 500)
	}
	if plain.Organization != nil && len(*plain.Organization) > 500 {
		return fmt.Errorf("field %s length: must be <= %d", "organization", 500)
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = AuthorDetail(plain)
	return nil
}

// A method to contact the author.
type ContactInformation struct {
	// Location for contacting, dependent on the method.
	At string `json:"at" yaml:"at" mapstructure:"at"`

	// Method for contact, such as 'email', 'homepage', 'mastodon'.  The corresponding
	// 'at' property reflects the location in the method's format.
	Method string `json:"method" yaml:"method" mapstructure:"method"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContactInformation) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["at"]; raw != nil && !ok {
		return fmt.Errorf("field at in ContactInformation: required")
	}
	if _, ok := raw["method"]; raw != nil && !ok {
		return fmt.Errorf("field method in ContactInformation: required")
	}
	type Plain ContactInformation
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.At) > 500 {
		return fmt.Errorf("field %s length: must be <= %d", "at", 500)
	}
	if len(plain.Method) > 50 {
		return fmt.Errorf("field %s length: must be <= %d", "method", 50)
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = ContactInformation(plain)
	return nil
}

// A hashed value and the corresponding hashing algorithm.
type Hash struct {
	// Algorithm name, such as 'sha1' and 'md5'
	Alg string `json:"alg" yaml:"alg" mapstructure:"alg"`

	// Base64 encoded signature.
	Sig string `json:"sig" yaml:"sig" mapstructure:"sig"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Hash) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["alg"]; raw != nil && !ok {
		return fmt.Errorf("field alg in Hash: required")
	}
	if _, ok := raw["sig"]; raw != nil && !ok {
		return fmt.Errorf("field sig in Hash: required")
	}
	type Plain Hash
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Alg) < 3 {
		return fmt.Errorf("field %s length: must be >= %d", "alg", 3)
	}
	if len(plain.Alg) > 10 {
		return fmt.Errorf("field %s length: must be <= %d", "alg", 10)
	}
	if len(plain.Sig) > 1000 {
		return fmt.Errorf("field %s length: must be <= %d", "sig", 1000)
	}
	*j = Hash(plain)
	return nil
}

// The Package URL (pURL).  For reference, see
// https://github.com/package-url/purl-spec/blob/master/PURL-SPECIFICATION.rst
type PUrl string

// UnmarshalJSON implements json.Unmarshaler.
func (j *PUrl) UnmarshalJSON(b []byte) error {
	type Plain PUrl
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString("^pkg:[a-z][a-z0-9.+-]*(/[a-zA-Z0-9._~%!$()*-]+)*/[a-zA-Z0-9._~%!$()*-]+(@[a-zA-Z0-9._~%!$()*-]+)?([?][a-zA-Z0-9._~%!$&()=*-]+=[a-zA-Z0-9._~%!$&()=*-]*(&[a-zA-Z0-9._~%!$&()=*-]+=[a-zA-Z0-9._~%!$&()=*-]*)*)?(#[a-zA-Z0-9._~%!$&()=*-]+(/[a-zA-Z0-9._~%!$&()=*-]+)*)?$", string(plain)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "^pkg:[a-z][a-z0-9.+-]*(/[a-zA-Z0-9._~%!$()*-]+)*/[a-zA-Z0-9._~%!$()*-]+(@[a-zA-Z0-9._~%!$()*-]+)?([?][a-zA-Z0-9._~%!$&()=*-]+=[a-zA-Z0-9._~%!$&()=*-]*(&[a-zA-Z0-9._~%!$&()=*-]+=[a-zA-Z0-9._~%!$&()=*-]*)*)?(#[a-zA-Z0-9._~%!$&()=*-]+(/[a-zA-Z0-9._~%!$&()=*-]+)*)?$", "")
	}
	if len(plain) > 500 {
		return fmt.Errorf("field %s length: must be <= %d", "", 500)
	}
	*j = PUrl(plain)
	return nil
}

// Details of the product that this document covers.
type ProductDefinition struct {
	// The formal name of the product.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The organization responsible for the maintenance of the product.
	Organization *string `json:"organization,omitempty" yaml:"organization,omitempty" mapstructure:"organization,omitempty"`

	// Purl corresponds to the JSON schema field "purl".
	Purl *PUrl `json:"purl,omitempty" yaml:"purl,omitempty" mapstructure:"purl,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProductDefinition) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ProductDefinition: required")
	}
	type Plain ProductDefinition
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Organization != nil && len(*plain.Organization) > 500 {
		return fmt.Errorf("field %s length: must be <= %d", "organization", 500)
	}
	*j = ProductDefinition(plain)
	return nil
}

type Sbom16Justification string

const Sbom16JustificationCodeNotPresent Sbom16Justification = "code_not_present"
const Sbom16JustificationCodeNotReachable Sbom16Justification = "code_not_reachable"
const Sbom16JustificationProtectedAtPerimeter Sbom16Justification = "protected_at_perimeter"
const Sbom16JustificationProtectedAtRuntime Sbom16Justification = "protected_at_runtime"
const Sbom16JustificationProtectedByCompiler Sbom16Justification = "protected_by_compiler"
const Sbom16JustificationProtectedByMitigatingControl Sbom16Justification = "protected_by_mitigating_control"
const Sbom16JustificationRequiresConfiguration Sbom16Justification = "requires_configuration"
const Sbom16JustificationRequiresDependency Sbom16Justification = "requires_dependency"
const Sbom16JustificationRequiresEnvironment Sbom16Justification = "requires_environment"

var enumValues_Sbom16Justification = []string{
	"code_not_present",
	"code_not_reachable",
	"requires_configuration",
	"requires_dependency",
	"requires_environment",
	"protected_by_compiler",
	"protected_at_runtime",
	"protected_at_perimeter",
	"protected_by_mitigating_control",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Sbom16Justification) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Sbom16Justification {
		if v == expected {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Sbom16Justification, v)
	}
	*j = Sbom16Justification(v)
	return nil
}

// A response to the vulnerability by the manufacturer, supplier, or project
// responsible for the affected component or service. More than one response is
// allowed. Responses are strongly encouraged for vulnerabilities where the
// analysis state is exploitable.
type Sbom16Response []Sbom16ResponseElem

type Sbom16ResponseElem string

const Sbom16ResponseElemCanNotFix Sbom16ResponseElem = "can_not_fix"
const Sbom16ResponseElemRollback Sbom16ResponseElem = "rollback"
const Sbom16ResponseElemUpdate Sbom16ResponseElem = "update"
const Sbom16ResponseElemWillNotFix Sbom16ResponseElem = "will_not_fix"
const Sbom16ResponseElemWorkaroundAvailable Sbom16ResponseElem = "workaround_available"

var enumValues_Sbom16ResponseElem = []string{
	"can_not_fix",
	"will_not_fix",
	"update",
	"rollback",
	"workaround_available",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Sbom16ResponseElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Sbom16ResponseElem {
		if v == expected {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Sbom16ResponseElem, v)
	}
	*j = Sbom16ResponseElem(v)
	return nil
}

type Sbom16State string

const Sbom16StateExploitable Sbom16State = "exploitable"
const Sbom16StateFalsePositive Sbom16State = "false_positive"
const Sbom16StateInTriage Sbom16State = "in_triage"
const Sbom16StateNotAffected Sbom16State = "not_affected"
const Sbom16StateResolved Sbom16State = "resolved"
const Sbom16StateResolvedWithPedigree Sbom16State = "resolved_with_pedigree"

var enumValues_Sbom16State = []string{
	"resolved",
	"resolved_with_pedigree",
	"exploitable",
	"in_triage",
	"false_positive",
	"not_affected",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Sbom16State) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Sbom16State {
		if v == expected {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Sbom16State, v)
	}
	*j = Sbom16State(v)
	return nil
}

// A single source file.  If lines are specified, then the hash signature must
// match the file's lines, in the line number order.
type SourceFile struct {
	// File corresponds to the JSON schema field "file".
	File string `json:"file" yaml:"file" mapstructure:"file"`

	// Hash corresponds to the JSON schema field "hash".
	Hash *Hash `json:"hash,omitempty" yaml:"hash,omitempty" mapstructure:"hash,omitempty"`

	// Lines corresponds to the JSON schema field "lines".
	Lines []int `json:"lines,omitempty" yaml:"lines,omitempty" mapstructure:"lines,omitempty"`

	AdditionalProperties interface{} `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SourceFile) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["file"]; raw != nil && !ok {
		return fmt.Errorf("field file in SourceFile: required")
	}
	type Plain SourceFile
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = SourceFile(plain)
	return nil
}

// A collection of analyses for how known vulnerabilities affect the software
// product.
type Vac10SchemaJson struct {
	// The schema ID that this document follows.
	Schema Vac10SchemaJsonSchema `json:"$schema" yaml:"$schema" mapstructure:"$schema"`

	// List of all constructed vulnerability analysis items.
	Analyses []AnalysisGroup `json:"analyses" yaml:"analyses" mapstructure:"analyses"`

	// Mapping of the alias of an author to the author details.  The remainder of the
	// document references the authors through the alias (map key).
	Authors Vac10SchemaJsonAuthors `json:"authors,omitempty" yaml:"authors,omitempty" mapstructure:"authors,omitempty"`

	// Product corresponds to the JSON schema field "product".
	Product ProductDefinition `json:"product" yaml:"product" mapstructure:"product"`
}

// Mapping of the alias of an author to the author details.  The remainder of the
// document references the authors through the alias (map key).
type Vac10SchemaJsonAuthors map[string]AuthorDetail

type Vac10SchemaJsonSchema string

const Vac10SchemaJsonSchemaHttpsRawGithubusercontentComGroboclownJuncoVamRefsHeadsMainVacV1SchemaJson Vac10SchemaJsonSchema = "https://raw.githubusercontent.com/groboclown/junco-vam/refs/heads/main/vac-v1.schema.json"

var enumValues_Vac10SchemaJsonSchema = []string{
	"https://raw.githubusercontent.com/groboclown/junco-vam/refs/heads/main/vac-v1.schema.json",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Vac10SchemaJsonSchema) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Vac10SchemaJsonSchema {
		if v == expected {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Vac10SchemaJsonSchema, v)
	}
	*j = Vac10SchemaJsonSchema(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Vac10SchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["$schema"]; raw != nil && !ok {
		return fmt.Errorf("field $schema in Vac10SchemaJson: required")
	}
	if _, ok := raw["analyses"]; raw != nil && !ok {
		return fmt.Errorf("field analyses in Vac10SchemaJson: required")
	}
	if _, ok := raw["product"]; raw != nil && !ok {
		return fmt.Errorf("field product in Vac10SchemaJson: required")
	}
	type Plain Vac10SchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Analyses) > 1000 {
		return fmt.Errorf("field %s length: must be <= %d", "analyses", 1000)
	}
	*j = Vac10SchemaJson(plain)
	return nil
}
